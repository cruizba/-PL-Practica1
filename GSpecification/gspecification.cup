/********************************************************************/
/********************************************************************/
/***** 		Autores: Carlos Ruiz Ballesteros (GII + GIS)		*****/
/*****			 Hector Ruiz Poveda	(GII + GIS)      			*****/
/********************************************************************/
/********************************************************************/


import java_cup.runtime.*;
import java.util.ArrayList;
action code{:
	public HTMLParser html = new HTMLParser();
	public int contador = 2;
:};
parser code{:

	//Poner en la memoria:
	//Estas dos variables son para detectar en las expresiones que tipo de valor devuelve
	//Al encontrar un token de tipo "+" "<"... segun estemos en una condicion if, o en un
	//case te informa si la expresion es incorrecta
	//por ejemplo si pones if (1 + 2), te devuelve un "expected boolean in ..."
	boolean if_expression = false;
	boolean case_expression = false;

	//Método para informar de error en un if
	//Este método es llamado si se recibe un token artimético
	public void error_if_exp(String s, int l, int c){
		//Si está a true estamos dentro de un if
		if(if_expression){
			l++;
			c++;
			report_error("Boolean expression expected. Line " + l + ", column " + c + "\n", null);
		}
	}

	//Método para informar de un error en un case
	// se activa al recibir un token de comparacion "<" ">" ...
	//los case según el enunciado solo pueden recibir enteros
	public void error_case_exp(String s, int l, int c){
		//Si está a true, estamos dentro de un case
		if(case_expression){
			l++;
			c++;
			report_error("Boolean expression expected. Line " + l + ", column " + c + "\n", null);
		}
	}

	//Poner en la memoria. Es un método que es llamado automáticamente al haber
	//un error en la gramática, con el que informamos de la linea y la columna
	//en el que se encuentra.
	@Override 
	public void syntax_error(Symbol s) { 
		int l = s.left + 1;
		int c = s.right + 1;
		report_error("*The String: " + s.value + " has produced a syntax error. Line " + l + ", column " + c + "\n", null);
	}
	@Override 
	public void unrecovered_syntax_error(Symbol s){
		
	}
:};

terminal program, begin, end, const_tok, var, procedure, function;
terminal integer, real, character;
terminal two_points, semicolon, dot, coma, equal, open_parenthesis, closed_parenthesis, assignment, lt, gt, le, ge;
terminal not_equal, plus, minus, multip, div, mod, or, and, not;
terminal identifier, numeric_integer_const, numeric_real_const, string_const;
terminal if_tok, then_tok, else_tok, while_tok, do_tok, for_tok, to, case_tok, of, type, array, square_bracket_open, square_bracket_close, double_dot, record;

non terminal PRG, BLQ, DCLLIST, SENTLIST;
non terminal DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM, TBAS;
non terminal SENT, ASIG, ID, EXP, OP, OPCOMP, OPARIT, OPLOG, FACTOR, SUBPARAMLIST, EXPLIST, PROC_CALL, EXEBLQ, DCLLIST_BLQ, DCL_BLQ;
non terminal COND, ELSECOND, WLOOP, FLOOP, CASE, CASELIST, ALLTYPES, DEFTYPE, TYPELIST, UDTYPE, DEFRANG;


precedence left lt;
precedence left gt;
precedence left le;
precedence left ge;
precedence left equal;
precedence left not_equal;
precedence left plus;
precedence left minus;
precedence left multip;
precedence left div;
precedence left mod;
precedence left or;
precedence left not;
precedence left and;
precedence left else_tok, if_tok;


/*Main Grammar*/
PRG ::=		 		program identifier:id {:html.matriz.get(0).add("<H1>Programa: "+id+"</H1>");:}semicolon BLQ dot {:html.createHTML("HTMLPrueba.html");:}|error dot;
BLQ ::= 			DCLLIST begin{:html.matriz.get(contador).add("<SPAN class='palres'> begin </SPAN> \n <BR> \n");:}
					SENTLIST end{:html.matriz.get(contador).add("<SPAN class='palres'>end</SPAN>");:};
DCLLIST ::= 		DCLLIST DCL | ;
SENTLIST ::= 		SENT | SENTLIST SENT;

/* Declaration's zone */
DCL ::= 			DEFCTE | DEFVAR | DEFPROC {:contador++; html.matriz.add(new ArrayList<String>());:} | DEFFUN {:contador++; html.matriz.add(new ArrayList<String>());:} | DEFTYPE;

DEFCTE ::= 			const_tok:ctet {:html.matriz.get(contador).add("<SPAN class='palres'>" + ctet + "</SPAN>");:} CTELIST;
CTELIST ::= 		identifier:id{:html.matriz.get(contador).add("<A name='"+ id + contador +"'><SPAN class='ident'>" + id + "</SPAN> =");:} equal SIMPVALUE semicolon{:html.matriz.get(contador).add("; \n <BR> \n");:} 
					| CTELIST identifier:id{:html.matriz.get(contador).add("<A name='"+ id + contador +"'><SPAN class='ident'>" + id + "</SPAN> =");:} equal SIMPVALUE semicolon{:html.matriz.get(contador).add("; \n <BR> \n");:} 
					|error semicolon;
SIMPVALUE ::=		numeric_integer_const:numi{:html.matriz.get(contador).add("<SPAN class='cte'>" + numi + "</SPAN>");:} | numeric_real_const:numr{:html.matriz.get(contador).add("<SPAN class='cte'>" + numr + "</SPAN>");:} | string_const:str{:html.matriz.get(contador).add("<SPAN class='cte'>" + str + "</SPAN>");:};

DEFVAR ::=			var{:html.matriz.get(contador).add("<A class='palres'>var</A>");:} DEFVARLIST semicolon{:html.matriz.get(contador).add("; \n <BR> \n");:} | error semicolon;
DEFVARLIST ::= 		VARLIST two_points{:html.matriz.get(contador).add(":");:} ALLTYPES | 
					DEFVARLIST semicolon{:html.matriz.get(contador).add("; \n <BR> \n");:} VARLIST two_points{:html.matriz.get(contador).add(":");:} ALLTYPES;
VARLIST ::=			identifier:id{:html.matriz.get(contador).add("<A name'" + id+contador + "'> \n <SPAN class='ident'>" + id +"</SPAN></A>");:} 
					| identifier:id{:html.matriz.get(contador).add("<A name'" + id+contador + "'> \n <SPAN class='ident'>" + id + "</SPAN>, </A>");:} coma VARLIST; 

DEFPROC ::= 		procedure identifier:identifier {:html.matriz.get(contador).add("<A NAME=\""+identifier+"\">\n"+"<SPAN CLASS=\"palres\">procedure</SPAN> <SPAN CLASS=\"ident\">"+identifier+"</SPAN> ( "); :} 
					FORMAL_PARAMLIST {:html.matriz.get(contador).add(")");:}
					semicolon{:html.matriz.get(contador).add("; \n <BR>");:}
					BLQ semicolon{:html.matriz.get(contador).add("; \n <BR>");:};

DEFFUN ::= 			function identifier:identifier {:html.matriz.get(contador).add("<A NAME=\""+identifier+"\">\n"+"<SPAN CLASS=\"palres\">function</SPAN> <SPAN CLASS=\"ident\">"+identifier+"</SPAN> ( "); :} 
					FORMAL_PARAMLIST {:html.matriz.get(contador).add(")");:} two_points{:html.matriz.get(contador).add(":");:}
					ALLTYPES semicolon {:html.matriz.get(contador).add("; \n <BR> \n");:}
					BLQ semicolon;

FORMAL_PARAMLIST ::=open_parenthesis FORMAL_PARAM closed_parenthesis | error closed_parenthesis;
FORMAL_PARAM ::=	VARLIST two_points ALLTYPES | VARLIST two_points FORMAL_PARAM semicolon FORMAL_PARAM| ;

TBAS ::=			integer:integ{:html.matriz.get(contador).add("<A class='palres'>" + integ +"</A>");:} 
					| real:r{:html.matriz.get(contador).add("<A class='palres'>"+ r + "</A>");:} 
					| character:c{:html.matriz.get(contador).add("<A class='palres'>"+ c + "</A>");:};


/* Sentencies zone */
SENT ::= 			ASIG semicolon {:html.matriz.get(contador).add("; \n <BR> \n");:}  | PROC_CALL semicolon {:html.matriz.get(contador).add("; \n <BR> \n");:} | EXEBLQ
					| COND | WLOOP | FLOOP | CASE| error semicolon SENT;

ASIG ::=			ID assignment{:html.matriz.get(contador).add(":=");:}  EXP;
ID ::= 				identifier:id{:html.matriz.get(contador).add("<A href='#"+ id + contador + "'>"+ id +"</A>");:} 
					| identifier:id square_bracket_open {:html.matriz.get(contador).add("<A href='#"+ id + contador + "'>"+ id +"</A> [");:}
					EXP square_bracket_close{:html.matriz.get(contador).add("]");:}
					|identifier dot identifier;
EXP ::=				EXP OP EXP | FACTOR;
OP ::= 				OPCOMP | OPLOG | OPARIT;
OPCOMP ::= 			lt:l{:error_case_exp((String)l, lleft, lright); html.matriz.get(contador).add(l.toString());:}
					| gt:g {:error_case_exp((String)g, gleft, gright); html.matriz.get(contador).add(g.toString());:}
					| le:le{:error_case_exp((String)le, leleft, leright); html.matriz.get(contador).add(le.toString());:}
					| ge:ge{:error_case_exp((String)ge, geleft, geright); html.matriz.get(contador).add(ge.toString());:}
					| equal:eq{:error_case_exp((String)eq, eqleft, eqright); html.matriz.get(contador).add(eq.toString());:}
					| not_equal:not_eq {:error_case_exp((String)not_eq, not_eqleft, not_eqright); html.matriz.get(contador).add(not_eq.toString());:};
// if we are in a condition, we check if the expression return a boolean value
OPARIT ::= 			plus:p{:error_if_exp((String) p, pleft, pright); html.matriz.get(contador).add(p.toString());:}
					| minus:m{:error_if_exp((String) m, mleft, mright); html.matriz.get(contador).add(m.toString());:}
					|multip:m{:error_if_exp((String) m, mleft, mright); html.matriz.get(contador).add(m.toString());:}
					| div:d{:error_if_exp((String) d, dleft, dright); html.matriz.get(contador).add(d.toString());:}
					| mod:m{:error_if_exp((String) m, mleft, mright); html.matriz.get(contador).add(m.toString());:};
OPLOG ::= 			or:o {:error_case_exp((String)o, oleft, oright); html.matriz.get(contador).add("<SPAN class'palres'>" + o +"</SPAN");:}
					| and:a{:error_case_exp((String)a, aleft, aright); html.matriz.get(contador).add("<SPAN class'palres'>" + a +"</SPAN");:};				
FACTOR ::= 			SIMPVALUE | not FACTOR | open_parenthesis{:html.matriz.get(contador).add("(");:}  EXP closed_parenthesis{:html.matriz.get(contador).add(")");:}
					| identifier:id{:html.matriz.get(contador).add("<A href='#"+ id + "'>"+ id +"</A>");:} SUBPARAMLIST 
					| identifier:id{:html.matriz.get(contador).add("<A href='#"+ id + contador + "'>"+ id +"</A>");:} square_bracket_open 
					EXP square_bracket_close{:html.matriz.get(contador).add("]");:}
					| identifier:id1{:html.matriz.get(contador).add("<A href='#"+ id1 + contador + "'>"+ id1 +"</A>");:} 
					dot{:html.matriz.get(contador).add(".");:} 
					identifier:id2{:html.matriz.get(contador).add("<A href='#"+ id2 + contador + "'>"+ id2 +"</A>");:} ;
SUBPARAMLIST ::= 	open_parenthesis{:html.matriz.get(contador).add("(");:} EXPLIST closed_parenthesis{:html.matriz.get(contador).add(")");:} | ;
EXPLIST ::=			EXP | EXP coma EXPLIST;

PROC_CALL ::=		identifier SUBPARAMLIST;

EXEBLQ ::= 			DCLLIST_BLQ begin SENTLIST end |error end;
DCLLIST_BLQ ::=		DCLLIST_BLQ semicolon DCL_BLQ | ;
DCL_BLQ ::= 		DEFCTE | DEFVAR;

COND ::=			if_tok{:if_expression = true;:} EXP then_tok{:if_expression = false;:} SENT ELSECOND;
ELSECOND ::= 		else_tok SENT| ;

WLOOP ::= 			while_tok{:if_expression = true;:} EXP do_tok{:if_expression = false;:} SENT;

FLOOP ::= 			for_tok identifier assignment EXP to EXP do_tok SENT;

CASE ::=			case_tok{:case_expression = true;:} EXP of{:case_expression = false;:} CASELIST end;
// Poner en la memoria que sobraba el punto y coma de la gramatica
// CASELIST ::= EXP ":" SENT ";" | EXP ":" SENT ";" CASELIST
CASELIST ::= 		EXP two_points SENT | EXP two_points SENT CASELIST;

DEFTYPE ::= 		type TYPELIST;
TYPELIST ::= 		identifier equal UDTYPE semicolon
					| identifier equal UDTYPE semicolon TYPELIST;
//Poner en memoria DEFRANG:
//Regla hecha para recuperarse de errores correctamene. Si surge un error en el rango, buscamos un corchete
// cerrado. Si no lo hay ejecutamos directamente ALLTYPES
DEFRANG ::=			square_bracket_open SIMPVALUE double_dot SIMPVALUE square_bracket_close
					| error square_bracket_close| error ALLTYPES;

UDTYPE ::= 			array  DEFRANG of ALLTYPES | record DEFVARLIST end;

ALLTYPES ::= 		TBAS | identifier;

